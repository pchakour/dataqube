{"common":{"plugin":{"license":"unknown","description":null,"details":null,"params":[{"name":"tag","type":"string","options":{"multi":true,"default":null},"description":"List of tag to add if the plugin is well executed"},{"name":"when","type":"string","options":{"default":null},"description":"Ruby predicate to indicate when execute this plugin"}]},"input":{"license":"unknown","description":"Read data from specific source using one of the following plugins:","details":null,"params":[]},"output":{"license":"unknown","description":"Send your data to a specific destination using one of the following plugins:","details":null,"params":[]},"transformer":{"license":"unknown","description":"Transform your data using one of the following plugins:","details":null,"params":[]},"extractor":{"license":"unknown","description":"Extract fields from your data using one of the following plugins:","details":null,"params":[]},"assertion":{"license":"unknown","description":"Check and validate your data using one of the following plugins:","details":null,"params":[{"name":"message","type":"string","options":{"default":null},"description":"Message to store when assert event"},{"name":"severity","type":["fatal","major","minor","info"],"options":{"default":"info"},"description":"Severity of the assertion"},{"name":"expected","type":["failure","success"],"options":{"default":"success"},"description":"Indicate if you expect the check failed or succeed"}]}},"input":{"tail":{"license":"community","description":"Tail files from a specific path","details":"\nThis plugin will add the file path to your event in a field named `filepath`.\n\n<CodeGroup>\n  <CodeGroupItem title='CONFIG'>\n\n```yaml\n- type: tail\n  path: /my/path/to/files/test.log\n  tag: LOG\n```\n\n  </CodeGroupItem>\n  <CodeGroupItem title='DATA'>\n\n```\nLos Angeles temperatures: [64, 65, 67, 67, 65, 65, 66]\nNew York temperatures: [68, 66, 70, 67, 65, 68, 70]\nParis temperatures: [59, 60, 62, 64, 58, 63, 64]\n```\n\n  </CodeGroupItem>\n  <CodeGroupItem title='OUTPUT'>\n\n```json{5-15}\n{\"message\":\"Los Angeles temperatures: [64, 65, 67, 67, 65, 65, 66]\",\"filepath\":\"/my/path/to/files/test.log\"}\n{\"message\":\"New York temperatures: [68, 66, 70, 67, 65, 68, 70]\",\"filepath\":\"/my/path/to/files/test.log\"}\n```\n\n  </CodeGroupItem>\n</CodeGroup>\n  ","params":[{"name":"path","type":"string","options":null,"description":"Path of fields to read. Wildcards are allowed to target multiple files"},{"name":"format","type":["auto","raw","json"],"options":{"default":"auto"},"description":"Decoding format of files. 'auto' use extension files to determine the right format"}]}},"output":{"elasticsearch":{"license":"community","description":"Output data to an Elasticsearch database","details":"\n\n  <CodeGroup>\n  <CodeGroupItem title='CONFIG'>\n  \n  ```yaml\n  - type: elasticsearch\n    scheme: https\n    user: admin\n    password: admin\n    cacert: path/to/cacert.pem\n  ```\n  \n  </CodeGroupItem>\n  </CodeGroup>\n\n  ","params":[{"name":"scheme","type":["http","https"],"options":{"default":"http"},"description":"Connection protocol to use, specify https if your Elasticsearch endpoint supports SSL"},{"name":"host","type":"string","options":{"default":"localhost"},"description":"The hostname of your Elasticsearch node"},{"name":"port","type":"integer","options":{"default":9200},"description":"The port number of your Elasticsearch node"},{"name":"index","type":"string","options":{"default":"dataqube"},"description":"The index name to write events to"},{"name":"user","type":"string","options":{"default":null},"description":"You can specify user for HTTP Basic authentication"},{"name":"password","type":"string","options":{"default":null},"description":"You can specify password for HTTP Basic authentication"},{"name":"cacert","type":"string","options":{"default":null},"description":"Need to verify Elasticsearch's certificate? You can use the following parameter to specify a CA"}]},"stdout":{"license":"community","description":"Output data to stdout","details":"\n\n  <CodeGroup>\n  <CodeGroupItem title='CONFIG'>\n  \n  ```yaml\n  - type: stdout\n  ```\n  \n  </CodeGroupItem>\n  </CodeGroup>\n\n  ","params":[]}},"transformer":{"add_field":{"license":"community","description":"This plugin allow you to add a new field in your record","details":"\n<CodeGroup>\n  <CodeGroupItem title='CONFIG'>\n\n```yaml{3-5}\n- tag: EXAMPLE_ADD_FIELD\n  transform:\n    - type: add_field\n      name: new_field_message\n      value: \"Message => %{message}\"\n```\n\n  </CodeGroupItem>\n  <CodeGroupItem title='EVENT'>\n\n  ```json\n  {\n    \"message\": \"Los Angeles temperatures: [64, 65, 67, 67, 65, 65, 66]\"\n  }\n  ```\n  \n  </CodeGroupItem>\n  <CodeGroupItem title='OUTPUT'>\n  \n  ```json{5-15}\n  {\n    \"message\": \"Los Angeles temperatures: [64, 65, 67, 67, 65, 65, 66]\",\n    \"new_field_message\": \"Message => Los Angeles temperatures: [64, 65, 67, 67, 65, 65, 66]\"\n    \"_dataqube.tags\": [\"EXAMPLE_ADD_FIELD\"],\n  }\n  ```\n  \n  </CodeGroupItem>\n</CodeGroup>\n  ","params":[{"name":"name","type":"string","options":null,"description":"New field name"},{"name":"value","type":"string","options":{"field_interpretation":true},"description":"New value field"}]},"date":{"license":"community","description":"Convert a string as a Date object","details":"\n::: warning\nThis plugin assert an error if the date parsing failed\n:::\n\n<CodeGroup>\n  <CodeGroupItem title='CONFIG'>\n\n```yaml{3-5}\n- tag: EXAMPLE_PARSE_DATE\n  extract:\n    - type: grok\n      pattern: ^%{TIMESTAMP_ISO8601:date} %{GREEDYDATA:log}$ \n  transform:\n    - type: date\n      source: date\n```\n\n  </CodeGroupItem>\n  <CodeGroupItem title='EVENT'>\n\n  ```json\n  {\n    \"message\": \"2023-07-07T06:51:20.763Z Temperatures: LosAngeles=65 NewYork=63 Paris=55\"\n  }\n  ```\n  \n  </CodeGroupItem>\n  <CodeGroupItem title='OUTPUT'>\n  \n  ```json{5-15}\n  {\n    \"message\": \"2023-07-07T06:51:20.763Z Temperatures: LosAngeles=65 NewYork=63 Paris=55\",\n    \"date\": \"2023-07-07T06:51:20.763Z\",\n    \"log\": \"Temperatures: LosAngeles=65 NewYork=63 Paris=55\",\n    \"_dataqube.tags\": [\"EXAMPLE_PARSE_DATE\"],\n    \"timestamp\": \"2023-07-07T06:51:20Z\"\n  }\n  ```\n  \n  </CodeGroupItem>\n</CodeGroup>\n  ","params":[{"name":"source","type":"string","options":null,"description":"Source to get date string"},{"name":"target","type":"string","options":{"default":"timestamp"},"description":"Target to write the date object. By default, the date object will be use as default event date by storing it in the timestamp field"},{"name":"format","type":"string","options":{"default":"iso8601"},"description":"\nDate format to use. You can set the format to a iso8601 or specify the format using the following list of formatting options:\n\n| option | description |\n|---|---|\n| %a | The abbreviated weekday name (“Sun”) |\n| %A | The full weekday name (“Sunday”) |\n| %b | The abbreviated month name (“Jan”) |\n| %B | The full month name (“January”) |\n| %c | The preferred local date and time representation |\n| %C | Century (20 in 2009) |\n| %d | Day of the month (01..31) |\n| %D | Date (%m/%d/%y) |\n| %e | Day of the month, blank-padded ( 1..31) |\n| %F | Equivalent to %Y-%m-%d (the ISO 8601 date format) |\n| %h | Equivalent to %b |\n| %H | Hour of the day, 24-hour clock (00..23) |\n| %I | Hour of the day, 12-hour clock (01..12) |\n| %j | Day of the year (001..366) |\n| %k | hour, 24-hour clock, blank-padded ( 0..23) |\n| %l | hour, 12-hour clock, blank-padded ( 0..12) |\n| %L | Millisecond of the second (000..999) |\n| %m | Month of the year (01..12) |\n| %M | Minute of the hour (00..59) |\n| %n | Newline (n) |\n| %N | Fractional seconds digits, default is 9 digits (nanosecond) |\n| %3N | millisecond (3 digits) |\n| %6N | microsecond (6 digits) |\n| %9N | nanosecond (9 digits) |\n| %p | Meridian indicator (“AM” or “PM”) |\n| %P | Meridian indicator (“am” or “pm”) |\n| %r | time, 12-hour (same as %I:%M:%S %p) |\n| %R | time, 24-hour (%H:%M) |\n| %s | Number of seconds since 1970-01-01 00:00:00 UTC. |\n| %S | Second of the minute (00..60) |\n| %t | Tab character (t) |\n| %T | time, 24-hour (%H:%M:%S) |\n| %u | Day of the week as a decimal, Monday being 1. (1..7) |\n| %U | Week number of the current year, starting with the first Sunday as the first day of the first week (00..53) |\n| %v | VMS date (%e-%b-%Y) |\n| %V | Week number of year according to ISO 8601 (01..53) |\n| %W | Week number of the current year, starting with the first Monday as the first day of the first week (00..53) |\n| %w | Day of the week (Sunday is 0, 0..6) |\n| %x | Preferred representation for the date alone, no time |\n| %X | Preferred representation for the time alone, no date |\n| %y | Year without a century (00..99) |\n| %Y | Year which may include century, if provided |\n| %z | Time zone as hour offset from UTC (e.g. +0900) |\n| %Z | Time zone name |\n"},{"name":"severity","type":["info","major","minor","fatal"],"options":{"default":"info"},"description":"Severity if the plugin assert an error"}]},"join":{"license":"community","description":"Join events","details":null,"params":[{"name":"by","type":"string","options":null,"description":"Key shared between events to join. This field is a ruby instruction."},{"name":"from","type":{"rule_tag":{"type":"string","desc":"Check if an event is tagged by the rule_tag"}},"options":null,"description":"Determine the beginning of a join section"},{"name":"until","type":{"rule_tag":{"type":"string","desc":"Check if an event is tagged by the rule_tag"}},"options":null,"description":"Determine the end of a join section"},{"name":"using","type":{"when":{"type":{"rule_tag":{"type":"string","desc":"Check if an event is tagged by the rule_tag"},"predicate":{"type":"string","desc":"Use Ruby predicate"}}},"code":{"type":"string","desc":"Ruby code to execute when conditions are met"}},"options":{"multi":true},"description":"What to do to join events"}]},"list":{"license":"community","description":"Parse a serialized list","details":null,"params":[{"name":"source","type":"string","options":{"default":"message"},"description":"Source field to parse"},{"name":"target","type":"string","options":{"default":null},"description":"Target field to store parsed data.\nBy default, the parsed data will be merged with the target field.\nIf no target is provided, the data will be merge with the event."},{"name":"overwrite","type":"boolean","options":{"default":false},"description":"Change the default behavior that merge parsed data with target. True will replace the target field value by the parsed data"}]},"remove_fields":{"license":"community","description":"Remove fields from an event","details":null,"params":[{"name":"source","type":"string","options":{"multi":true},"description":"Field to remove. Accept an array to delete several fields at once"}]},"ruby":{"license":"community","description":"Execute ruby code","details":null,"params":[{"name":"once","type":"string","options":{"default":null},"description":"Code executed once at the startup. Could be useful to initialize some variables."},{"name":"each","type":"string","options":{"default":""},"description":"Code executed for each event"}]},"split":{"license":"community","description":"\n  Split an event in several events based on the specified field\n\n  ::: warning\n    Limitation only one by tag and at the end of the transform section\n  :::\n  ","details":null,"params":[{"name":"source","type":"string","options":{"multi":true},"description":"Field to split in several events. You can specify an array"}]},"uuid":{"license":"community","description":"Generate a unique id in the specified target","details":null,"params":[{"name":"target","type":"string","options":null,"description":"Field in which stored the unique id"}]}},"extractor":{"grok":{"license":"community","description":"Extract informations using grok patterns","details":"\n::: warning\nThis plugin assert an error if the extraction process failed depending on the match result and the [expected](#expected) parameter.\n:::\n\n<CodeGroup>\n<CodeGroupItem title='CONFIG'>\n\n```yaml{3-4}\n- tag: EXTRACT_TEMPERATURES\n  extract:\n    - type: grok\n      pattern: \"Los Angeles temperatures: %{GREEDYDATA:temperatures}\"\n```\n\n</CodeGroupItem>\n<CodeGroupItem title='EVENT'>\n\n```json\n{\n\"message\": \"Los Angeles temperatures: [64, 65, 67, 67, 65, 65, 66]\"\n}\n```\n\n</CodeGroupItem>\n<CodeGroupItem title='OUTPUT'>\n\n```json{3}\n{\n\"message\": \"Los Angeles temperatures: [64, 65, 67, 67, 65, 65, 66]\",\n\"temperatures\": [64, 65, 67, 67, 65, 65, 66],\n\"_dataqube.tags\": [\"EXTRACT_TEMPERATURES\"]\n}\n```\n\n</CodeGroupItem>\n</CodeGroup>\n","params":[{"name":"source","type":"string","options":{"default":"message"},"description":"Source field on which apply the grok pattern"},{"name":"pattern","type":"string","options":{"multi":true},"description":"Pattern grok to use. You can specify several patterns to check"},{"name":"severity","type":["info","major","minor","fatal"],"options":{"default":"info"},"description":"Severity error"},{"name":"expected","type":["failure","success"],"options":{"default":"success"},"description":"Indicate if you expect the check failed or succeed"},{"name":"overwrite","type":"boolean","options":{"default":false},"description":"Change the default merge behavior with overwriting"}]},"kv":{"license":"community","description":"Extract data using key value pattern","details":"\n\n<CodeGroup>\n<CodeGroupItem title='CONFIG'>\n\n```yaml{3-4}\n- tag: EXTRACT_TEMPERATURES\n  extract:\n    - type: kv\n      source: message\n```\n\n</CodeGroupItem>\n<CodeGroupItem title='EVENT'>\n\n```json\n{\n\"message\": \"Temperatures: LosAngeles=65 NewYork=63 Paris=55\"\n}\n```\n\n</CodeGroupItem>\n<CodeGroupItem title='OUTPUT'>\n\n```json{3-5}\n{\n  \"message\": \"Temperatures: LosAngeles=65 NewYork=63 Paris=55\",\n  \"LosAngeles\": \"65\",\n  \"NewYork\": \"63\",\n  \"Paris\": \"55\",\n  \"_dataqube.tags\": [\"EXTRACT_TEMPERATURES\"]\n}\n```\n\n</CodeGroupItem>\n</CodeGroup>\n\n  ","params":[{"name":"source","type":"string","options":null,"description":"Source field to use for the extraction"}]}},"assertion":{"contains":{"license":"community","description":"Check if an array contains a specific value","details":"\n  <CodeGroup>\n  <CodeGroupItem title='CONFIG'>\n\n```yaml{10-12}\n- tag: EXTRACT_TEMPERATURES\n  extract:\n    - type: grok\n      pattern: \"Los Angeles temperatures: %{GREEDYDATA:temperatures}\"\n  transform:\n    - type: list\n      source: temperatures\n      overwrite: true\n  assert:\n    - type: contains\n      source: temperatures\n      value: 50\n```\n\n  </CodeGroupItem>\n  <CodeGroupItem title='EVENT'>\n\n```json\n{\n  \"message\": \"Los Angeles temperatures: [64, 65, 67, 67, 65, 65, 66]\"\n}\n```\n\n  </CodeGroupItem>\n  <CodeGroupItem title='OUTPUT'>\n\n```json{5-15}\n{\n  \"message\": \"Los Angeles temperatures: [64, 65, 67, 67, 65, 65, 66]\",\n  \"temperatures\": [64, 65, 67, 67, 65, 65, 66],\n  \"_dataqube.tags\": [\"EXTRACT_TEMPERATURES\"],\n  \"_dataqube.quality\": [\n    {\n      \"tag\": \"EXTRACT_TEMPERATURES\",\n      \"message\": \"Field temperatures must contain 50\",\n      \"severity\": \"info\",\n      \"expected\": \"50\",\n      \"value\": \"[64, 65, 67, 67, 65, 65, 66]\",\n      \"status\": \"unresolved\",\n      \"id\": \"641b49e6-449e-4fbc-bd98-25829d77c3fc\"\n    }\n  ]\n}\n```\n\n  </CodeGroupItem>\n</CodeGroup>\n","params":[{"name":"source","type":"string","options":null,"description":"Source field to check. The field must be an array."},{"name":"value","type":"any","options":{"field_interpretation":true},"description":"Value to find in the array"}]},"empty":{"license":"community","description":"Check if a field value is empty","details":"\n  Empty `string`, `array` and the value `nil` are consider empty by the plugin.\n\n  <CodeGroup>\n  <CodeGroupItem title='CONFIG'>\n\n```yaml{10-12}\n- tag: EXTRACT_TEMPERATURES\n  extract:\n    - type: grok\n      pattern: \"Los Angeles temperatures: %{GREEDYDATA:temperatures}\"\n  transform:\n    - type: list\n      source: temperatures\n      overwrite: true\n  assert:\n    - type: empty\n      source: temperatures\n      expected: failure # We want the temperatures field not empty\n```\n\n  </CodeGroupItem>\n  <CodeGroupItem title='EVENT'>\n\n```json\n{\n  \"message\": \"Los Angeles temperatures: []\"\n}\n```\n\n  </CodeGroupItem>\n  <CodeGroupItem title='OUTPUT'>\n\n```json{5-15}\n{\n  \"temperatures\": [],\n  \"message\": \"Los Angeles temperatures: []\",\n  \"_dataqube.tags\": [\"EXTRACT_TEMPERATURES\"],\n  \"_dataqube.quality\": [\n    {\n      \"tag\": \"EXTRACT_TEMPERATURES\",\n      \"message\": \"Fields temperatures are empty\",\n      \"severity\": \"info\",\n      \"expected\": \"![\"\", nil, []]\",\n      \"value\": \"[]\",\n      \"status\": \"unresolved\",\n      \"id\": \"803471cc-9b1b-4e15-96c8-1979ec4260fe\"\n    }\n  ]\n}\n```\n\n  </CodeGroupItem>\n</CodeGroup>\n","params":[{"name":"source","type":"string","options":{"multi":true},"description":"Source field to check"}]},"eq":{"license":"community","description":"Check if a field value is equal to a specified value","details":"\n<CodeGroup>\n  <CodeGroupItem title='CONFIG'>\n\n```yaml{6-8}\n- tag: EXPECTED_TEMPERATURE\n  extract:\n    - type: grok\n      pattern: \"Los Angeles max temperature is %{NUMBER:temperature:int} expected %{NUMBER:expected:int}\"\n  assert:\n    - type: eq\n      source: temperature\n      value: \"%{expected:int}\" # Use field interpretation here\n```\n\n  </CodeGroupItem>\n  <CodeGroupItem title='EVENT'>\n\n```json\n{\n  \"message\": \"Los Angeles max temperature is 68 expected 50\"\n}\n```\n\n  </CodeGroupItem>\n  <CodeGroupItem title='OUTPUT'>\n\n```json{6-16}\n{\n  \"temperature\": 68,\n  \"expected\": 50,\n  \"message\": \"Los Angeles max temperature is 68 expected 50\",\n  \"_dataqube.tags\": [\"EXPECTED_TEMPERATURE\"],\n  \"_dataqube.quality\": [\n    {\n      \"tag\": \"EXPECTED_TEMPERATURE\",\n      \"message\": \"Fields temperature not matching\",\n      \"severity\": \"info\",\n      \"expected\": \"50\",\n      \"value\": \"68\",\n      \"status\": \"unresolved\",\n      \"id\": \"1dd3d1fa-46eb-4ef0-b02f-1a30f850b7ec\"\n    }\n  ]\n}\n```\n\n  </CodeGroupItem>\n</CodeGroup>\n  ","params":[{"name":"source","type":"string","options":{"multi":true},"description":"Source field to check"},{"name":"value","type":"any","options":{"field_interpretation":true},"description":"Value to compare"}]},"size":{"license":"community","description":"Check if the size of an array is include between a min and a max. Min and max are included.","details":"\n  <CodeGroup>\n  <CodeGroupItem title='CONFIG'>\n\n```yaml{10-13}\n- tag: EXTRACT_TEMPERATURES\n  extract:\n    - type: grok\n      pattern: \"Los Angeles temperatures: %{GREEDYDATA:temperatures}\"\n  transform:\n    - type: list\n      source: temperatures\n      overwrite: true\n  assert:\n    - type: size\n      source: temperatures\n      min: 1\n      max: 5\n```\n\n  </CodeGroupItem>\n  <CodeGroupItem title='EVENT'>\n\n```json\n{\n  \"message\": \"Los Angeles temperatures: [64, 65, 67, 67, 65, 68]\"\n}\n```\n\n  </CodeGroupItem>\n  <CodeGroupItem title='OUTPUT'>\n\n```json{5-15}\n{\n  \"temperatures\": [64, 65, 67, 67, 65, 68],\n  \"message\": \"Los Angeles temperatures: [64, 65, 67, 67, 65, 68]\",\n  \"_dataqube.tags\": [\"EXTRACT_TEMPERATURES\"],\n  \"_dataqube.quality\": [\n    {\n      \"tag\": \"EXTRACT_TEMPERATURES\",\n      \"message\": \"Fields temperatures size must be between or equal to 1 and 5\",\n      \"severity\": \"info\",\n      \"expected\": \"[1, 5]\",\n      \"value\": \"6\",\n      \"status\": \"unresolved\",\n      \"id\": \"9587b5e6-4cb7-4f09-8b70-11577673dee1\"\n    }\n  ]\n}\n```\n\n  </CodeGroupItem>\n</CodeGroup>\n","params":[{"name":"source","type":"string","options":null,"description":"Source field to check. The field must be an array."},{"name":"min","type":"integer","options":{"default":0},"description":"Min value"},{"name":"max","type":"integer","options":{"default":0},"description":"Max value"}]}}}